; Notes and analysis of the Sinclair Scientific ROM
; 
; EXP: exponent mask
; DIGIT1, DIGIT: used with AKCN increment. MASK3 is 1. Don't overlap with 4.
; MANT: the A value?
; EXP_S5: negative exponent
; NEWEXP: E pressed, entering a new exponent
; 
; FLAGS:
; A
; 0 ALL
; 1 (S9) FLAG1A
; 3 (S5) UP_LOW
; 5 (S10) LOW
; 7 (S8) TAN
; 11 (S4) COS_TAN
; 
; B
; 0 ALL
; 1 (S9) EMODE
; 6 (S6S7) FLAG6B ??two bits??
; 7 (S8) EMODE2
; 
; Constants
; 0: ....
; 1: .*.* 5
; 2: ....
; 3: ...* 1
; 4: ....
; 5: ...* 1
; 6: ...* 1
; 7: .*.* 5
; 8: ....
; 9: ...* 1
; a: ...* 1
; b: ...* 1
; c: .*.* 5
; d: ...* 1
; e: .*.. 4
; f: ....
; 
; Masks:
;  S value
; a9876543210
; 00000000000 mask 0 ALL
; 5           mask 1 MANT_S5
;   00        mask 2 EXP
;     1       mask 3 DIGIT1
;     0000000 mask 4 MANT
;           1 mask 5 MANTLOW1
;   01        mask 6 EXP1
;  5          mask 7 EXP_S5
; 000000      mask 8 TOPSTUFF
; 0001        mask 9 EXPSGNS1
;     0000001 mask a MANT1
;      1      mask b MASKA1
;     00005   mask c MANTD5
;     00001   mask d MANTD1
;     4       mask e DIGIT4
;     0       mask f DIGIT

0   START    ZFA    ALL ; init - clear flags
1            ZFB    ALL
2            AKA    ALL ; clear A and C
3            AKC    ALL
4   MAINLOOP SLLA   MANT ; Restore mantissa
5            AKB    ALL ; clear B
6   WAITSCAN SYNC
7            SCAN
8            BINE   WAITSCAN
9   WAITKEY  WAITNO WAITED
10  WAITED2  SYNC
11           SCAN
12           BIE    WAITKEY ; loop if no key
13           SYNC
14           SRLA   MANT
15           BKO    LOWERKEY
16           BKO    PLUSKEY
17           BKO    MINUSKEY
18           BKO    DIVKEY
19           BKO    MULTKEY
20           BKO    UPPERKEY
21           BKO    EKEY
22           BKO    ZEROKEY
23           EXAB   ALL ; save A in B, A=0
24           AKCN   DIGIT1 ; count column into A
25           EXAB   ALL ; restore A, B holds count
26           BINE   MAINLOOP ; branch if nothing pressed
27  ZEROKEY  TFB    EMODE ; B holds key 0-9
28           BINE   EDIGIT
29           TFB    FLAG6B ; if FLAG6B...
30           BIE    LABEL33
31           AKA    ALL ; then clear A and FLAG6B
32           ZFB    FLAG6B
33  LABEL33  ACKA   DIGIT ; C holds digit position
34  BSHIFT   SRLB   ALL ; shift B right C times.
35           SAKA   DIGIT1 ; decrement A
36           BIE    BSHIFT (no borrow)
37           ACKC   DIGIT1 ; increment C
38           AABA   MANT ; Append new digit
39           BIE    MAINLOOP ; done digit processing
40  EDIGIT   ZFB    NEWEXP ; clear new exponent flag
41           SLLA   EXP ; shift exponent left
42           SLLB   ALL ; shift digit left
43           AABA   EXP ; append new digit to exponent
44           BIE    MAINLOOP ; done
45  EKEY     SFB    EMODE ; entering exponent mode
46           SFB    NEWEXP
47           BIE    MAINLOOP ; done
48  LOWERKEY SFA    LOW ; LOW and UP_LOW set for LOWER key
49  UPPERKEY SFA    UP_LOW ; UP_LOW set for UPPER key
50           BIE    MAINLOOP ; done
51  MINUSKEY TFA    UP_LOW ; alt-MINUS is COS
52           BINE   COSKEY
53           TFB    NEWEXP ; - follows E?
54           BIE    SETNEG
55           AAKA   EXP_S5 ; negate exponent
56           BIE    MAINLOOP ; if already neg, fall through subtract
57  SETNEG   AAKA   MANT_S5 ; negate mantissa
58           BIE    PLUSKEY ; clear condition flag
59  PLUSKEY  TFA    UP_LOW ; alt-PLUS is SIN
60           BINE   SINKEY
61  ADDSUB   AKC    DIGIT ; Clear C DIGIT
62           ACKB   ALL ; copy C to B
63           ABAC   EXP ; add exponents into C
64           BIE    CLRCC ; Clear condition code
65  CLRCC    ABAC   EXP_S5 ; add exponent signs
66           SCKC   EXP_S5 ; subtract 5 from sign
67           BIE    EXPSNES ; signs were different
68           CAB    EXP ; compare exponents
69           BIE    EXPAGE ; branch >=
70           EXAB   ALL ; switch arguments so A EXP > B EXP
71  EXPAGE   SABC   EXP ; same sign - subtract exponents into C
72  EXPSNES  CAK    EXP_S5 ; Test A exponent sign
73           BINE   AEXPPOS ; branch on borrow, A exp sign == 0
74           EXAB   ALL ; switch arguments so A EXP > B EXP
75  AEXPPOS  CAK    MANT1 ; what is MANT1?
76           BIE    BSHIFT2
77           EXAB   ALL
78  BSHIFT2  SCKC   EXP1 ; shift B by difference in exponents (C) to line up
79           BINE   DONE2
80           SRLB   MANT
81           BIE    BSHIFT2 ; branch every time
82  DONE2    ABAC   MANT_S5 ; add mantissa signs and subtract 5
83           SCKC   MANT_S5
84           BIE    SUBTR ; signs different
85  TRYADD   AABA   MANT ; add mantissas, or restore A if did SUBTR
86           BIE    WRAPUP ; branch if no overflow, i.e. did add
87           EXAB   MANT ; failed subtract: swap A and B and try again.
88           EXAB   MANT_S5
89  SUBTR    SABA   MANT ; subtract mantissa
90           BINE   TRYADD ; A was smaller than B: try again
91           BIE    WRAPUP ; branch every time, success
92  SIGNSNE  CAB    EXP ; compare EXP signs
93           BIE    LABEL95 ; branch A >= B
94           EXAB   EXPSGNS1 ; swap
95  LABEL95  SABA   EXP ; subtract EXPs
96           BIE    EXPSDONE ; branch every time
97  DIVKEY   TFA    UP_LOW ; entry point for DIV
98           BINE   TANKEY ; alt-DIV is TAN
99           SFA    COS_TAN ; why set COS? Doesn't make sense
100 LABEL100 SFA    RET1FLAG ; 'subroutine call' flag
101          BIE    WRAPUP ; 'Subroutine call' to align A
102 RET1     ZFA    RET1FLAG ; 'Return' to RET1
103          AAKA   EXP_S5 ; toggle EXP sign
104          BIE    MULTKEY ; clear cc
105 MULTKEY  TFA    UP_LOW ; alt-MULT is LOG
106          BINE   LOGKEY
107          AKC    DIGIT ; clear C DIGIT, whatever that is
108          ACKB   ALL ; copy C to B
109          EXAB   MANT
110          ABAC   EXP_S5
111          SCKC   EXP_S5
112          BIE    SIGNSNE ; branch if signs different
113          AABA   EXP ; add exponents
114 EXPSDONE AABA   MANT_S5 ; xor signs
115          BIE    CLRCC2 ; clear before test
116 CLRCC2   TFA    COS_TAN
117 LABEL117 AKA    MANT
118          BINE   LABEL279 ; branch if COS or TAN
119 MLTLOOP1 SRLA   MANT ; multiply B * C
120 MLTLOOP2 CCK    MANTLOW1 ; Add B to A, repeat low digit of C times
121          BINE   LABEL125
122          SCKC   MANT1
123          AABA   MANT
124          BIE    MLTLOOP2
125 LABEL125 SRLC   MANT ; shift C right
126          CCK    MANT1
127          BIE    MLTLOOP1 ; loop if not done
128          TFA    LOW
129          BINE   ALOGRET ; Return to LABEL308 if LOW flag set (ANTILOG)
130 WRAPUP   CAK    MANT1 ; Test if mantissa is < 1
131          BINE   START ; if mantissa is 0, reset
132 MANTSHL  CAK    DIGIT1 ; Loop to left-align mantissa
133          BIE    MANTOK ; Branch if mantissa aligned
134          SLLA   MANT ; Put mantissa back into place
135          CAK    EXP_S5 ; Check sign
136          BIE    MANTNEG ; Branch if negative
137          SAKA   EXP1 ; Decrement exponent
138          BIE    LABEL141 ; Branch if no borrow
139          AKA    EXP_S5 ; Set exponent sign
140          AKA    EXP1 ; Set exponent to 1
141 LABEL141 SAKA   EXP1 ; Decrement exponent
142 MANTNEG  AAKA   EXP1 ; Increment exponent
143          BIE    MANTSHL ; first will clear flag
144          BIE    MANTSHL ; BET
145 MANTOK   SRLA   MANT
146          CAK    EXP_S5 ; Test exponent sign
147          BINE   EXPPOS
148          SAKA   EXP1 ; Decrement exponent
149          SAKA   EXP1 ; Decrement exponent
150 EXPPOS   AAKA   EXP1 ; Increment exponent
151          BIE    CLRCC1 ; clear condition
152 CLRCC1   TFA    RET1FLAG ; Subroutine return?
153          BINE   RET1 ; return to RET1 if RET1FLAG set
154          ZFB    ALL ; Clear B
155          SFB    FLAG6B ; Set op done flag?
156          ZFA    ALL ; Clear A flags
157          CAK    EXP1 ; Is exponent zero (< 1)
158          BIE    EXPPOS2
159 LABEL159 AAKA   EXP_S5 ; Flip sign
160          BIE    LABEL159 ; Branch if sign was clear before
161 EXPPOS2  AAKC   ALL ; Copy A to C
162          BIE    MAINLOOP ; BET
163 TANKEY   SFA    TAN
164 COSKEY   SFA    COS_TAN
165 SINKEY   SAKA   EXP1 ; shift mantissa by exponent
166          BINE   DONESHFT
167          SRLA   MANT
168          BIE    SINKEY
169 DONESHFT AKA    EXPSGNS1 ; clear signs
170          SAKA   EXPSGNS1 ; EXP = 0
171          AKC    ALL ; clear C
172          TFA    LOW ; check for ARC-
173          BIE    NORMOP ; branch if no
174          TFA    TAN ; check ARCTAN?
175          BIE    ASINCOS ; branch if no
176          AAKC   ALL ; doing ARCTAN
177          AKB    MASKA1
178          BIE    TRGLOOP2 ; branch every time
179 ASINCOS  AAKA   MANTD1
180 NORMOP   AKB    MANTD5 ; B = .0005 (current SIN)
181          SRLB   MANT
182          ACKC   MASKA1 ; C += 1 (current COS)
183 TRIGLOOP SAKA   MANTD1 ; rotate A times, by .001 rad
184          BINE   TRIGDONE ; branch on borrow - done
185 TRGLOOP2 SLLC   ALL ; shift C to prepare for add
186          SLLC   ALL
187          SLLC   ALL
188          ACKC   MANTD5 ; C=C-B/1000 (rounded)
189          SCBC   ALL
190          SRLC   ALL ; restore C
191          SRLC   ALL
192          SRLC   ALL
193          SLLB   ALL ; shift B to prepare for add
194          SLLB   ALL
195          SLLB   ALL
196          ACKC   MANTD5 ; B=B+C/1000 (rounded)
197          ABCB   ALL
198          SCKC   MANTD5 ; restore C
199          SRLB   ALL
200          SRLB   ALL
201          SRLB   ALL
202          TFA    LOW ; ARC-op?
203          BIE    TRIGLOOP ; no: branch
204          AAKA   EXPSGNS1 ; ARC-op
205          TFA    TAN
206          BIE    ISSINCOS ; branch if SIN/COS
207          CCK    DIGIT1 ; doing TAN, compare C to K
208          BINE   TRGLOOP2 ; loop if not done
209          BIE    TRIG2 ; BET
210 ISSINCOS TFA    COS_TAN ; SIN/COS
211          BINE   ISCOS ; branch if COS
212          CAB    MANT ; must be SIN
213          BIE    TRGLOOP2
214          BIE    TRIG2 ; Branch every time
215 ISCOS    CAK    MANT1 ; COS
216          EXAB   MANT ; compare C-A the hard way
217          CCB    MANT
218          EXAB   MANT
219          BIE    TRGLOOP2 ; C==A
220 TRIG2    SRLA   ALL ; shift A right 5
221          SRLA   ALL
222          SRLA   ALL
223          SRLA   ALL
224          SRLA   ALL
225          BIE    WRAPUP ; done if A zero
226 TRIGDONE TFA    TAN
227          BIE    SINCOS
228          ACKA   ALL ; doing TAN: A=C (denom)
229          ABOC   ALL ; C=B (numer)
230          AKB    ALL ; B=0
231          ZFA    UP_LOW
232          BIE    LABEL100 ; branch every time
233 SINCOS   TFA    COS_TAN
234          BIE    SIN ; branch for SIN
235          ACKB   ALL ; COS: return C via B
236 SIN      EXAB   ALL ; SIN: return B
237          BIE    WRAPUP ; BET (no overflow)
238 LOGKEY   TFA    LOW ; low-MULT is antilog
239          BIE    LOG
240 ANTILOG  CAK    EXP1 ; antilog - loop
241          BINE   LABEL248
242          CAK    EXP_S5
243          BINE   LABEL247
244          SRLA   MANT
245          SAKA   EXP1
246          BIE    ANTILOG
247 LABEL247 SLLA   MANT
248 LABEL248 AKA    EXP
249          SLLA   TOPSTUFF
250          SLLA   TOPSTUFF
251 LOG      AKC    ALL ; This loop computes log(.1)/log(.99) = 229
252          ACKC   DIGIT1 ; C = 1000000
253 LOGLOOP  ACKB   MANT ; Compute log B*.99^C until < .1
254          SRLB   MANT
255          SRLB   MANT
256          SCBC   MANT ; C -= C / 100
257          TFB    NEWEXP
258          BINE   ALOGLOOP
259          ACKC   EXPSGNS1 ; Count number of iterations
260          CCK    MASKA1 ; C vs 100000
261          BIE    LOGLOOP ; Loop if >=
262          SCBB   EXPSGNS1 ; Left over bit from B is .15
263          ABCC   MANT
264          SCKC   MASKA1
265          SRLB   ALL ; Shift 229 into B mantissa
266          SRLB   ALL
267          SRLB   ALL
268          SRLB   ALL
269          ABCB   MANT ; add .15
270          EXAB   MANT ; 229.15 in A, arg in B
271          TFA    LOW
272          BINE   ANTILOG ; return to ANTILOG every time through if LOW set
273          ABOC   ALL ; Copy B (arg) to C
274          FFA    TAN ; using this flag for something?
275          TFA    TAN
276          BINE   LOGLOOP ; back to the loop
277          AAKC   MANT
278 LABEL278 AKA    MANT ; clear A mant, arg exp still in A
279 LABEL279 AKA    DIGIT4 ; start digit count at 4, iterate until 10
280 DODIV    CCB    MANT ; Compute C/B into A
281          BINE   SHIFTDIV ; C-B: branch if not less than
282          SCBC   MANT ; C -= B
283          AAKA   MANT1 ; A++
284          BIE    DODIV ; BET
285 SHIFTDIV AAKC   DIGIT1 ; shift remainder C left, increase mantissa
286          BINE   LABEL291 ; so C > B
287          SLLA   MANT
288          ACKA   DIGIT
289          SLLC   MANT
290          BIE    DODIV ; until count hits 10
291 LABEL291 AKA    DIGIT
292          TFA    UP_LOW ; pick the return target
293          BINE   LOGSKIP
294          BIE    WRAPUP
295 WAITED   BIE    WAITED2 ; inconvenient WAITNO target
296 LOGSKIP  AAKC   MANT ; A mantissa -> C
297          AKA    MANT ; clear A mantissa
298          SRLA   ALL ; shift exponent into top of mantissa (log of exponent)
299          SRLA   ALL
300          AKA    EXP ; clear exponent
301          BIE    ADDSUB ; BET (clear from AAKC)
302 ANTILOG  AAKC   MANT
303          AKA    MANT
304          AKA    MASKA1
305          SABA   MANT
306          EXAB   MANT
307          BIE    LABEL117 ; Sub call to multiply by 229.15
308 ALOGRET  SRLA   MANT
309          SFB    NEWEXP
310          BIE    LOG ; Branch every time
311 ALOGLOOP SAKA   MANTD1
312          BIE    LOGLOOP
313          AAKA   MANTD1
314          SLLA   MANT
315          AAKA   MASKA1
316          ABCC   MANT
317          EXAB   MANT
318          ZFA    UP_LOW
319          BINE   LABEL278 ; branch every time
